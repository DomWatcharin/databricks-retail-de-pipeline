# 21_silver_products_scd2
from pyspark.sql import functions as F, Window

spark.sql("USE CATALOG retail")
spark.sql("USE core")

bronze = spark.table("bronze_products") \
    .select("product_id","sku","name","category","price") \
    .withColumn("price", F.col("price").cast("decimal(10,2)"))

# If first run, create SCD2 table
spark.sql("""
CREATE TABLE IF NOT EXISTS dim_product (
  product_id INT,
  sku STRING,
  name STRING,
  category STRING,
  price DECIMAL(10,2),
  valid_from TIMESTAMP,
  valid_to   TIMESTAMP,
  is_current BOOLEAN
) USING DELTA
""")

# Upsert logic (type 2): close old record if price changed, open new one
from delta.tables import DeltaTable
target = DeltaTable.forName(spark, "dim_product")

updates = bronze.withColumn("valid_from", F.current_timestamp()) \
                .withColumn("valid_to",   F.lit(None).cast("timestamp")) \
                .withColumn("is_current", F.lit(True))

# 1) Close out rows where price changed
spark.sql("""
MERGE INTO dim_product tgt
USING (
  SELECT product_id, price FROM bronze_products
) src
ON  tgt.product_id = src.product_id AND tgt.is_current = TRUE
WHEN MATCHED AND tgt.price <> src.price THEN
  UPDATE SET tgt.valid_to = current_timestamp(), tgt.is_current = FALSE
""")

# 2) Insert new current rows for products not present or price changed
spark.sql("""
MERGE INTO dim_product tgt
USING (
  SELECT product_id, sku, name, category, CAST(price AS DECIMAL(10,2)) AS price
  FROM bronze_products
) src
ON  tgt.product_id = src.product_id AND tgt.is_current = TRUE AND tgt.price = src.price
WHEN NOT MATCHED BY TARGET THEN INSERT *
""")

display(spark.table("dim_product").limit(10))
